
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>GTFS — Least Worst Frequency (Strict Grace)</title>
<style>
  body{font-family: ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;max-width:1200px;margin:0 auto;padding:24px;background:#f8fafc}
  h1{margin:0 0 16px}
  .card{background:#fff;border:1px solid #e5e7eb;border-radius:12px;box-shadow:0 2px 8px rgba(0,0,0,.04);padding:16px;margin:16px 0}
  label{font-weight:600;display:block;margin:8px 0 4px}
  input[type="time"],input[type="file"]{border:1px solid #d1d5db;border-radius:8px;padding:8px 10px;font-size:14px;width:100%}
  .grid{display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px}
  button{background:#111827;color:#fff;border:0;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer}
  table{width:100%;border-collapse:collapse;font-size:14px}
  th,td{border:1px solid #e5e7eb;padding:8px 10px;text-align:center}
  th{background:#f1f5f9;position:sticky;top:0}
  .muted{color:#6b7280}
  .small{font-size:12px}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
</head>
<body>
  <h1>GTFS — Least Worst Frequency (Strict Grace)</h1>
  <div class="card">
    <div class="grid">
      <div>
        <label>GTFS ZIP</label>
        <input id="gtfs" type="file" accept=".zip">
      </div>
      <div>
        <label>Start</label>
        <input id="t0" type="time" value="07:00">
      </div>
      <div>
        <label>End</label>
        <input id="t1" type="time" value="22:00">
      </div>
    </div>
    <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;align-items:center">
      <button id="go" disabled>Analyze</button>
      <span class="muted small">Rule: ≤2 gaps within +2min grace; any gap &gt; (tier+2) fails that tier.</span>
    </div>
  </div>

  <div id="out" class="card" style="display:none">
    <div style="overflow:auto; max-height:70vh">
      <table id="tbl">
        <thead>
          <tr>
            <th>Route</th>
            <th>Dir</th>
            <th>Day</th>
            <th>≤10</th><th>11–15</th><th>16–20</th><th>21–30</th><th>31–60</th><th>&gt;60</th>
            <th>Avg</th>
            <th>Least‑Worst Tier</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

<script>
const fileEl=document.getElementById('gtfs');
const btn=document.getElementById('go');
fileEl.addEventListener('change',e=>btn.disabled=!e.target.files[0]);
btn.addEventListener('click',analyze);

function t2m(s){const p=(s||'').split(':');if(p.length<2)return null;return (+p[0])*60+(+p[1]);}
function parseCsv(text){
  return new Promise(res=>Papa.parse(text,{header:true,skipEmptyLines:true,complete:r=>{
    const clean=r.data.filter(row=>Object.values(row).some(v=>v&&String(v).trim()!==''));res(clean);
  }}));
}
function bucketCounts(headways){
  const b={'≤10':0,'11–15':0,'16–20':0,'21–30':0,'31–60':0,'>60':0};
  for(const h of headways){
    if(h<=10)b['≤10']++;
    else if(h<=15)b['11–15']++;
    else if(h<=20)b['16–20']++;
    else if(h<=30)b['21–30']++;
    else if(h<=60)b['31–60']++;
    else b['>60']++;
  }
  return b;
}
// STRICT grace: at most 2 gaps where T < h <= T+2; any h > T+2 fails immediately.
function leastWorstTier(headways){
  const tiers=[10,15,20,30,60,Infinity];
  const GRACE=2, MAX_GRACE_COUNT=2;
  for(const T of tiers){
    if(T===Infinity) return '>60';
    let graceCount=0;
    let fail=false;
    for(const h of headways){
      if(h<=T) continue;
      if(h<=T+GRACE){
        graceCount++;
        if(graceCount>MAX_GRACE_COUNT){ fail=true; break; }
      }else{ // strictly beyond grace
        fail=true; break;
      }
    }
    if(!fail){
      return String(T);
    }
  }
  return '>60';
}

async function analyze(){
  const file=fileEl.files[0]; if(!file) return;
  const t0=t2m(document.getElementById('t0').value);
  const t1=t2m(document.getElementById('t1').value);

  const zip=await JSZip.loadAsync(file);
  const need=['routes.txt','trips.txt','stop_times.txt','calendar.txt'];
  for(const n of need){ if(!zip.file(n)) { alert(n+' missing'); return; } }

  const [routes,trips,stopTimes,calendar]=await Promise.all([
    parseCsv(await zip.file('routes.txt').async('text')),
    parseCsv(await zip.file('trips.txt').async('text')),
    parseCsv(await zip.file('stop_times.txt').async('text')),
    parseCsv(await zip.file('calendar.txt').async('text')),
  ]);

  const routeById={}; for(const r of routes){ if(r.route_id) routeById[r.route_id]=r; }
  const calByService={}; for(const c of calendar){ if(c.service_id) calByService[c.service_id]=c; }

  // origin departure per trip
  const originForTrip=new Map();
  {
    const best=new Map();
    for(const st of stopTimes){
      const tid=st.trip_id; if(!tid) continue;
      const seq=parseInt(st.stop_sequence||'0',10);
      const prev=best.get(tid);
      if(!prev || seq<prev.seq) best.set(tid,{seq,row:st});
    }
    for(const [tid,obj] of best.entries()){
      const r=obj.row;
      const dep=(r.departure_time&&r.departure_time.trim())?r.departure_time:r.arrival_time;
      const m=t2m(dep);
      if(m!=null) originForTrip.set(tid,m);
    }
  }

  function tripsForDay(day){
    return trips.filter(tr=>{
      const c=calByService[tr.service_id];
      if(!c) return false;
      if(day==='Weekday') return ['monday','tuesday','wednesday','thursday','friday'].some(d=>c[d]==='1');
      if(day==='Saturday') return c['saturday']==='1';
      if(day==='Sunday') return c['sunday']==='1';
      return false;
    });
  }

  const days=['Weekday','Saturday','Sunday'];
  const rows=[];

  for(const day of days){
    const dayTrips=tripsForDay(day);
    const map=new Map();
    for(const tr of dayTrips){
      const dir=(tr.direction_id!==undefined && tr.direction_id!=='' && tr.direction_id!==null)? tr.direction_id : '0';
      const key=`${tr.route_id}::${dir}`;
      if(!map.has(key)) map.set(key,[]);
      map.get(key).push(tr.trip_id);
    }

    for(const [key,tripIds] of map.entries()){
      const [route_id,dir]=key.split('::');
      const rt=routeById[route_id]||{};
      const rname=rt.route_short_name||rt.route_long_name||route_id;

      const times=[];
      for(const tid of tripIds){
        const m=originForTrip.get(tid);
        if(m==null) continue;
        if(m<t0 || m>t1) continue;
        times.push(m);
      }
      if(times.length<2) continue;
      times.sort((a,b)=>a-b);

      const gaps=[];
      for(let i=1;i<times.length;i++){
        const h=times[i]-times[i-1];
        if(h>=5 && h<=240) gaps.push(h);
      }
      if(gaps.length===0) continue;

      const b=bucketCounts(gaps);
      const avg=Math.round(gaps.reduce((a,b)=>a+b,0)/gaps.length);
      const tier=leastWorstTier(gaps);

      rows.push({route:rname, dir, day, b, avg, tier});
    }
  }

  rows.sort((a,b)=>{
    if(a.route!==b.route) return (''+a.route).localeCompare(''+b.route,undefined,{numeric:true});
    const order={'Weekday':0,'Saturday':1,'Sunday':2};
    if(a.day!==b.day) return order[a.day]-order[b.day];
    return (''+a.dir).localeCompare(''+b.dir);
  });

  const tbody=document.querySelector('#tbl tbody');
  tbody.innerHTML='';
  for(const r of rows){
    const tr=document.createElement('tr');
    tr.innerHTML=`
      <td>${r.route}</td>
      <td>${r.dir}</td>
      <td>${r.day}</td>
      <td>${r.b['≤10']}</td>
      <td>${r.b['11–15']}</td>
      <td>${r.b['16–20']}</td>
      <td>${r.b['21–30']}</td>
      <td>${r.b['31–60']}</td>
      <td>${r.b['>60']}</td>
      <td>${r.avg}</td>
      <td>${r.tier} min</td>
    `;
    tbody.appendChild(tr);
  }
  document.getElementById('out').style.display='block';
}
</script>
</body>
</html>
